#импортируем библиотеки:
#pygame - для помощи в создании графики, управлении мышкой и клавиатурой
#math - для рассчетов
#random - для получения случайных значений
#PyQt5 - для всплывающего окна, чтобы закрыть игру
import pygame
import math
import random
from PyQt5 import QtCore, QtWidgets
import sys

# для начала было бы неплохо написать
# всю разметку там, обозначить границы карты
# и сделать остальную рутину
#размер окна
win_sx = 20  # количество квадратов по икс
win_sy = 20  # по игрек
side_s = 30  # сторона

width = win_sx * side_s + 1  # ширина окна
height = win_sy * side_s + 1  # его высота
fps = 30  # кадровая частота

# цвета
red = (255, 0, 0)
dark_red = (155, 0, 0)
green = (0, 255, 0)
dark_green = (0, 155, 0)
blue = (0, 0, 255)
dark_blue = (0, 0, 155)
black = (0, 0, 0)
white = (255, 255, 255)
yellow = (255, 255, 0)

pygame.init()  # активизация библиотеки пайгейм

win = pygame.display.set_mode((width, height))  # создаем окно с заданными парамаетрами, где будет игра
pygame.display.set_caption("Tower defence")  # подпись
clock = pygame.time.Clock()  # часы


# функция отрисовки карты чтобы разделить ее на равные клетки

def draw_wind():
    """данная функция отрисовывает линии на равном расстоянии,
    разделяя наше открытое окно на квадраты, а также помогает увидеть,
    на какой квадрат указывает курсор мышки
    mp - положение мышки на поле
    x - координата мышки по оси х
    y - координата мышки по оси у
    """
    mp = pygame.mouse.get_pos()
    x = math.floor(mp[0] / side_s) * side_s
    y = math.floor(mp[1] / side_s) * side_s
    pygame.draw.rect(win, dark_blue, [x, y, side_s, side_s])
    for Line in range(win_sx + 1):
        pygame.draw.line(win, dark_green, [Line * side_s, 0], [Line * side_s, height * side_s])
    for Line in range(win_sy + 1):
        pygame.draw.line(win, dark_green, [0, Line * side_s], [width, Line * side_s])


# создаем класс башни
class tower:
    """метод класса для отрисовки башни с необхимыми параметрами
    x - координата по оси х
    y - координата по у
    size - размер башни
    color - ее цвет
    damage - урон, который башня наносит врагу
    fire - время через которое летит следующая пуля
    fire time - таймер
    """

    # данные для рисовки
    def __init__(self, x, y, size, color, damage, fire):
        self.x = x
        self.y = y
        self.size = size
        self.color = color
        self.damage = damage
        self.fire = fire
        self.fire_time = 0

    # создание башни
    def draw(self):
        """функция котооая ставит башню по нажатию на пробел"""
        pygame.draw.circle(win, self.color, [self.x, self.y], self.size)

    # pew pew
    def shoot(self):
        """добавим задержку чтобы пули не летели подряд"""
        if self.fire_time <= 0:
            put_w(self.x, self.y, 10, white, 2, 3)
            self.fire_time = self.fire
        else:
            self.fire_time -= 1 / fps


towers = []  # список хранит информацию о башнях


# ставит башню
def put_t():
    """функция ставит башню на указанную клетку по нажатию пробела
    учитывая что башня ставится в центр квадрата,
    прибавляем к координате половину длины стороны клетки
    округляя в меньшую сторону координаты мыши узнаем
    квадрат на который указываем
    mp - положение мышки на поле
    x - координата мышки по оси х
    y - координата мышки по оси у
    key - клавиша на которую нажимаем"""
    mp = pygame.mouse.get_pos()
    x = math.floor(mp[0] / side_s) * side_s
    y = math.floor(mp[1] / side_s) * side_s
    keys = pygame.key.get_pressed()
    if keys[pygame.K_SPACE] and tow_ok(x, y):
        towers.append(tower(x + side_s / 2, y + side_s / 2, 10, yellow, 5, 2))


# наживаем врагов
class enemy:
    """метод класса для отрисовки врагов с необхимыми параметрами
    x - координата по оси х
    y - координата по у
    size - размер врага
    color - их цвет
    heal - сколько может выдержать/хп
    fast - скорость передвижения
    dot - количество поворотов
    """

    # данные для рисовки
    def __init__(self, x, y, size, color, heal, fast):
        self.x = x
        self.y = y
        self.size = size
        self.color = color
        self.heal = heal
        self.fast = fast
        self.dot = 0

    # создание цепочки врагов
    def draw(self):
        """функция рисует одного рвага"""
        pygame.draw.circle(win, self.color, [self.x, self.y], self.size)

    # движение врагов по дотам
    def go_en(self):
        """функция, которая будет двигать врагов вплоть до поворотов,
        менять напрвление и проверять, если враг дошел до конца дороги,
        то враг уничтожается
        go - список, со вложенным в него: ед. векторы по х([0]) и у([1]) и расстояние([2])"""
        go = fcnmath(self.x, check[self.dot][0], self.y, check[self.dot][1])
        self.x += self.fast * go[0]
        self.y += self.fast * go[1]
        if go[2] <= self.fast:
            self.dot += 1
            if self.dot == len(check):
                enem.remove(self)


enem = []  # список хранит информацию о врагах >:(

number_enem = random.randint(10, 50)
# сколько
def put_e(size, color, heal, fast):
    """формирует нам цепочку врагов, случайной длины от 10 до 50"""
    for i in range(number_enem):
        x = check[0][0] - 200 - i * 10 - 5
        y = check[0][1]
        enem.append(enemy(x, y, size, color, heal, fast))


# пуля-дура
class weapon:
    """метод класса для отрисовки пули с необхимыми параметрами
    x - координата по оси х
    y - координата по у
    speed - скорость передвижения
    col - ее цвет
    death - урон который несет пуля
    size - размер пули
    """

    # данные для рисовки
    def __init__(self, x, y, speed, col, death, size):
        self.x = x
        self.y = y
        self.speed = speed
        self.col = col
        self.death = death
        self.size = size

    # создание пули
    def draw(self):
        """функция создает пулю"""
        pygame.draw.circle(win, self.col, [self.x, self.y], self.size)

    # движение пули
    def go(self, nx_v, ny_v):
        """функция задает направление движения пули и
        заставляет ее лететь"""
        self.x += nx_v * self.speed
        self.y += ny_v * self.speed


weapons = []  # список для хравния и функция создания


# бесконечный магазин
def put_w(x, y, speed, col, death, size):
    """функция подаёт пулю с определенными параметрами"""
    weapons.append(weapon(x, y, speed, col, death, size))


# хард матеша
def fcnmath(x1, x2, y1, y2):
    """функция, которая вычисляет вектор движения, расстояние и
    арктангенс угла направления
    x1 - координата по х начальной точки
    x2 - координата по х конечной точки
    y1 - координата по у начальной точки
    y2 - координата по у конечной точки
    d - расстояние между начальной и конечной точкой
    nx_v - единичный вектор по х
    ny_v - единичный вектор по у
    a - арктанценс угла направления
    """
    x_v = x2 - x1
    y_v = y2 - y1
    d = math.hypot(x_v, y_v)
    nx_v = x_v / d
    ny_v = y_v / d
    a = math.atan2(ny_v, nx_v)
    return nx_v, ny_v, d, a


# чекаем аппартаменты чтобы поставить можно было
def tow_ok(x, y):
    """функция проверяет можно ли поставить башню на квадрат
    это нельзя сделать в двух случаях:
    1) на этом квадрате уже есть башня
    2) этот квадрат является частью дороги
    x - координата х на которую указывает курсор
    y - координата у на которую указывает курсор
    tower - вспомогательная переменная необходимая для работы со списком towers
    step - вспомогательная переменная необходимая для работы со списком road
    """
    x += side_s / 2
    y += side_s / 2
    if len(towers) != 0:
        for tower in towers:
            if tower.x == x and tower.y == y:
                return False
    for step in road:
        if step[0] + side_s / 2 == x and step[1] + side_s / 2 == y:
            return False
    return True


# создадим поле игры
# в ней 0 это простое поле а по всем остальным числам кроме 0 враг будет наступать

field1 = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 1, 6, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 1, 8],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

field2 = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 0],
    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 0],
    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 0],
    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 13, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

field3 = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0],
]


# выбор карты чисто случайно
def field_choose():
    """функция рандомно выбирает одну из трех карт"""
    many_fields = [field1, field2, field3]
    field = random.choice(many_fields)
    return field


a = field_choose()  # выбранная карта

road = []  # список хранит информацию о клетке карты


# дорога
def do_r():
    """функция прокладывает маршрут"""
    for i in range(len(a)):
        for j in range(len(a[0])):
            if a[i][j] > 0:  # запретим ставить башни на дороге
                road.append([j * side_s, i * side_s, side_s, side_s])
    return road


# рисует дорогу
def put_r(col):
    """функция рисует дорогу из прямоугольников
    col - цвет дороги
    x - вспомогательная переменная
    """
    for x in road:
        pygame.draw.rect(win, col, x)


check = []  # хранит информацию о поворотах


# враг наступает
def checkpoin():
    """функцию поможет врагу двигаться
    на каждом повороте будет точка к которой надо приблизиться
    dot - переменная
    проходя до поворота переменная дот увеличивается на 1
    если значение в клетке совпадает с дотом,
    то врагу следует сменить направление"""
    # sude_s = 30
    dot = 2
    for x in range(4):
        for i in range(len(a)):
            for j in range(len(a[0])):
                if a[i][j] == dot:
                    check.append([j * side_s + side_s / 2, i * side_s + side_s / 2])
                    dot += 1
    return check

    """надо в углы карты написать цифры начиная с 2"""


# я вас уничтожу
def death_check():
    """функция которая проверяет сколбко у врага осталось хп
    и если это значение равно нулю то первый из них удаляется"""
    for enemy in enem:
        if enemy.heal <= 0:
            enem.remove(enemy)


# тело программы
def main():
    """главная функция. по сути это и есть наша игра
    рисуем игровое поле -> рисуем дорогу -> можем поставить башни ->
    -> отрисовываем башни -> запускаем врагов -> проверяем могут
    ли они существовать -> проверяем исправность снаряда и
    стреляем по первому в цепочке врагу -> врагу - урон, нам - минус
    пуля -> создается новая пуля -> прооверяем на смерть врага"""
    draw_wind()
    put_t()
    put_r(white)
    for tower in towers:
        tower.draw()
        tower.shoot()
    for enemy in enem:
        enemy.draw()
        enemy.go_en()
    death_check()
    for weapon in weapons:
        if enem:
            a = fcnmath(weapon.x, enem[0].x, weapon.y, enem[0].y)
            weapon.go(a[0], a[1])
            if a[2] <= weapon.speed:
                enem[0].heal -= weapon.death
                weapons.remove(weapon)
            weapon.draw()
    death_check()


do_r()  # вызываем функцию рисовки дороги
answer = checkpoin() # вызываем функцию работы с поворотами
# print(answer)
put_e(8, red, 10, 3)  # создаем врагов

# запуск программы  (смотрели в интернете, как делать)
if __name__ == "__main__":
    run = True
    """Добавим таймер для отрисовки игры каждый 30 миллисекунд (fps)"""
    timer_event = pygame.USEREVENT + 1
    pygame.time.set_timer(timer_event, fps)
    """Игровой цикл"""
    while run:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
            elif event.type == timer_event:
                win.fill(black)
                main()
                pygame.display.update()

# завершение игры

    app = QtWidgets.QApplication(sys.argv)
    window = QtWidgets.QWidget(flags=QtCore.Qt.Dialog)
    window.setWindowTitle("Вы точно хотите закрыть эту замечательную игру ?")
    window.resize(450, 100)
    button1 = QtWidgets.QPushButton("Close ", window)
    button1.setFixedSize(200, 50)
    button1.move(225, 30)
    button1.clicked.connect(window.update)
    button2 = QtWidgets.QPushButton("Закрыть ", window)
    button2.setFixedSize(200, 50)
    button2.move(20, 30)
    button2.clicked.connect(window.close)
    window.show()
    sys.exit(app.exec_())
pygame.quit()

# ура победа